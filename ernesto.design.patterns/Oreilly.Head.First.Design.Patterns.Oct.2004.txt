/*
***********
* Unit 1: *
***********
*/

Sharpen your pencil

Which of the following are disadvantages of using inheritance to provide Duck behavior? (Choose all that apply.)

*   A. Code is duplicated across subclasses.
*   B. Runtime behavior changes are difficult.
    C. We can’t make ducks dance.
*   D. Hard to gain knowledge of all duck behaviors.
    E. Ducks can’t fly and quack at the same time.
*   F. Changes can unintentionally affect other ducks.

Design Puzzle

Abstract Class Character: 
    WeaponBehavior wb

    fight()
    setWeapon()

King, queen, troll, knight extends Character;

Interface WeaponBehavior:
    useWeapon()

KnifeBehavior, BowAndArroyBehavior, AxeBehavior, SwordBehavior implements WeaponBehavior;

/*
***********
* Unit 2: *
***********
*/

Sharpen your pencil

Based on our first implementation, which of the following apply? (Choose all that apply.)

*   A. We are coding to concrete implementations, not interfaces.
*   B. For every new display element we need to alter code.
*   C. We have no way to add (or remove) display elements at run time.
    D. The display elements don’t implement a common interface.
*   E. We haven’t encapsulated the part that changes.
    F. We are violating encapsulation of the WeatherData class.

Sharpen your pencil

Before moving on, try sketching out the classes you’ll need to implement the Weather Station, including the WeatherData class and its display elements. Make sure your diagram shows how all the pieces fit together and also how another developer might implement her own display element. 

If you need a little help, read the next page; your teammates are already talking about how to design the Weather Station.

Interface Subject{}
WeatherData implements Subject{subjectBehab(); weatherAttributesGetters/Setters(); weatherChanged();}

Interface Subscriber
Interface Display
DisplayWeatherSubs implements Subscriber, Display{subscribersBehab(); weatherAttributesUpdater(); weatherAttributesDisplay();}

Brain Power

Mary and Sue thought that passing the measurements directly to the observers was the most straightforward method of updating state. Do you think this is wise? 
No, in case of new meassures we need to update the method and every implementation.

Hint: is this an area of the application that might change in the future? If it did change, would the change be well encapsulated, or would it require changes in many parts of the code?
Yes, the update method. It'd require changes on every implementation.

Can you think of other ways to approach the problem of passing the updated state to the observers?
Not right now.

Code Magnets

/**
The ForecastDisplay class is all scrambled up on the fridge. Can you reconstruct the code snippets to make it work? Some of the curly braces fell on the floor and they were too small to pick up, so feel free to add as many of those as you need!
**/

import java.util.Observable;
import java.util.Observer;

public class ForecastDisplay implements Observer, DisplayElement {

    private float currentPressure = 29.92f;
    private float lastPressure;

    public ForecastDisplay(Observable observable) {
        observable.addObserver(this);
    }

    public void update(Observable observable, Object arg) {
        if (observable instanceof WeatherData) {
            WeatherData weatherData = (WeatherData) observable;
            lastPressure    = currentPressure;
            currentPressure = weatherData.getPressure();
            display();
        }
    }
    public void display() {
        // display code here
    }

}

Design Principle Challenge

For each design principle, describe how the Observer Pattern makes use of the principle.

Design Principle: Identify the aspects of your application that vary and separate them from what stays the same.
    This is present when implements the observable and observer abs-class and interface, respectively.

    The thing that varies in the Observer Pattern is the state of the Subject and the number and types of Observers. With this pattern, you can vary the objects that are dependent on the state of the Subject, without having to change that Subject. That’s called planning ahead!

Design Principle: Program to an interface, not an implementation.
    Both the Subject and Observer use interfaces. The Subject keeps track of objects implementing the Observer interface, while the observers register with, and get notified by, the Subject interface. As we’ve, this keeps things nice and loosely coupled.

Design Principle: Favor composition over inheritance.
    This is when obligate to who implements, practice the same behavior.

    The Observer Pattern uses composition to compose any number of Observers with their Subjects. These relationships aren’t set up by some kind of inheritance hierarchy. No, they are set up at runtime by composition!

/*
***********
* Unit 3: *
***********
*/

====== SHARPEN YOUR PENCIL ======
public class Beverage extends BeveragePrices {
    public double cost() {
        double cost = 0;

        if(hasMilk()) {
            cost = cost + getMilkPrice();
        }

        if(hasSoy()) {
            cost = cost + getSoyPrice();
        }

        if(hasMocha()) {
            cost = cost + getMochaPrice();
        }

        if(hasWhip()) {
            cost = cost + getWhipPrice();
        }

        return cost;
    }
}

public class DarkRoast extends Beverage {
    public DarkRoast() {
       description = "Most Excellent Dark Roast";
    }

    public double cost() {
        double cost = 0;

        if(hasMilk()) {
            cost = cost + getMilkPrice();
        }

        if(hasSoy()) {
            cost = cost + getSoyPrice();
        }

        if(hasMocha()) {
            cost = cost + getMochaPrice();
        }

        if(hasWhip()) {
            cost = cost + getWhipPrice();
        }

        return cost;        
    }
}

What requirements or other factors might change that will impact this design?

    Price changes for condiments will force us to alter existing code.
    New condiments will force us to add new methods and alter the cost method in the superclass.
    We may have new beverages. For some of these beverages (iced tea?), the condiments may not be appropriate, yet the Tea subclass will still inherit methods like hasWhip().
    What if a customer wants a double mocha?
    we don't see the particular price of the single beverage
    what if a customer combines two bevarages in one (espresso + decaf)?
    what if a customer wants a different proportion of the bevarage(?)
    Similars beverage (like espresso and dark) could have the same cost associated, so, the cost method bust be implemented twice

Brain Power

Before going further, think about how you’d implement the cost() method of the coffees and the condiments. Also think about how you’d implement the getDescription() method of the condiments.
    COST
    coffes:
        Cost(){
            return cost;
        }
    condiments:
        Cost(){
            if(beverage != null){
                cost += beverage.Cost();
            }
            return cost;
        }
    DESCRIPTION
    condiments:
        getDescription() {
            String description = null;
            if(beverage != null) {
                description = " with milk";
            }
            return description;
        }

New barista training

Make a picture for what happens when the order is for a "double mocha soy latte with whip" beverage. Use the menu to get the correct prices, and draw your picture using the same format we used earlier (from a few pages back):

HINT: you can make a "double mocha soy latte with whip" by combining HouseBlend, Soy, two shots of Mocha and Whip!

(Whip Cost():0.10 (Mocha Cost():0.20 (Mocha Cost():0.20 (Soy  Cost():0.15 (HouseBlend Cost():0.89)))))
Total cost: 65+89: 1.54